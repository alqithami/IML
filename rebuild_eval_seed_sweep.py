#!/usr/bin/env python3
"""
Rebuild evaluation-seed sweep tables from per-run eval_seed*.csv files.

Expected inputs (generated by scripts/run_sweep.sh or your own evaluation loop):
  runs/<run_name>/eval_seed0.csv
  runs/<run_name>/eval_seed1.csv
  ...

Outputs:
  results/eval_seed_sweep.csv       # one row per (run_name, eval_seed)
  results/eval_seed_sweep_agg.csv   # aggregated over eval_seed, per run_name

Run from repo root:
  python rebuild_eval_seed_sweep.py
"""
from __future__ import annotations

import re
from pathlib import Path

import pandas as pd


RUNS_DIR = Path("runs")
OUT_DIR = Path("results")
OUT_DIR.mkdir(exist_ok=True)


def parse_run_name(run_name: str) -> dict:
    """
    Parse run naming convention used by the sweep scripts, e.g.:
      cleanup_baseline_agents5_seed3
      harvest_iml_agents5_seed0
    """
    parts = run_name.split("_")
    out = {"run_name": run_name}
    # Best-effort parsing; keep robust if format changes.
    if len(parts) >= 2:
        out["env"] = parts[0]
        out["condition"] = parts[1]
    # agentsX
    for p in parts:
        m = re.fullmatch(r"agents(\d+)", p)
        if m:
            out["num_agents"] = int(m.group(1))
    # seedY (training seed)
    for p in parts:
        m = re.fullmatch(r"seed(\d+)", p)
        if m:
            out["train_seed"] = int(m.group(1))
    return out


def summarize_eval_file(csv_path: Path) -> dict:
    """Compute per-eval-seed summary statistics from an eval_seed*.csv file."""
    df = pd.read_csv(csv_path)
    # These columns are produced by iml_ssd.experiments.evaluate
    # and are per-episode (one row per episode).
    out = {}
    if "return_mean" in df.columns:
        out["return_mean"] = float(df["return_mean"].mean())
    if "return_gini" in df.columns:
        out["gini"] = float(df["return_gini"].mean())
    # In the IML condition, iml_sanctions corresponds to applied sanctions.
    if "iml_sanctions" in df.columns:
        out["net_sanctions"] = float(df["iml_sanctions"].mean())
    else:
        out["net_sanctions"] = 0.0
    # Helpful for sanity checks
    out["n_episodes"] = int(len(df))
    return out


def main() -> None:
    eval_files = sorted(RUNS_DIR.glob("*/eval_seed*.csv"))
    print(f"found_files {len(eval_files)}")
    rows = []
    for f in eval_files:
        m = re.search(r"eval_seed(\d+)\.csv$", f.name)
        if not m:
            continue
        eval_seed = int(m.group(1))
        run_name = f.parent.name
        row = parse_run_name(run_name)
        row["eval_seed"] = eval_seed
        row.update(summarize_eval_file(f))
        rows.append(row)

    df = pd.DataFrame(rows)
    # Order columns (if present)
    preferred = [
        "run_name", "env", "condition", "num_agents", "train_seed", "eval_seed",
        "return_mean", "gini", "net_sanctions", "n_episodes",
    ]
    cols = [c for c in preferred if c in df.columns] + [c for c in df.columns if c not in preferred]
    df = df[cols].sort_values(["run_name", "eval_seed"]).reset_index(drop=True)

    out_csv = OUT_DIR / "eval_seed_sweep.csv"
    df.to_csv(out_csv, index=False)
    print(f"wrote_rows_eval_seed_sweep {len(df)}")
    if "eval_seed" in df.columns:
        print("unique_eval_seeds", sorted(df["eval_seed"].unique().tolist()))

    # Aggregate over eval seeds per run_name
    metric_cols = [c for c in ["return_mean", "gini", "net_sanctions"] if c in df.columns]
    if metric_cols:
        agg = (
            df.groupby(["run_name", "env", "condition", "num_agents", "train_seed"], dropna=False)[metric_cols]
            .agg(["mean", "std"])
            .reset_index()
        )
        # Flatten multi-index columns
        agg.columns = [
            "_".join([x for x in col if x]).rstrip("_") if isinstance(col, tuple) else col
            for col in agg.columns
        ]
    else:
        agg = df.groupby(["run_name"], dropna=False).size().reset_index(name="n_rows")

    out_csv_agg = OUT_DIR / "eval_seed_sweep_agg.csv"
    agg.to_csv(out_csv_agg, index=False)
    print(f"wrote_rows_eval_seed_sweep_agg {len(agg)}")


if __name__ == "__main__":
    main()
